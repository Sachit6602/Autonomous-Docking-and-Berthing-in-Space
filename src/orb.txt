#!/usr/bin/env python3

import rospy
from gazebo_msgs.srv import SetModelState
from gazebo_msgs.msg import ModelState
from geometry_msgs.msg import Vector3, Quaternion
import math

class SatelliteController:
    def __init__(self):
        rospy.init_node('satellite_controller', anonymous=True)
        rospy.wait_for_service('/gazebo/set_model_state')
        self.set_state_service = rospy.ServiceProxy('/gazebo/set_model_state', SetModelState)

        # Initial static parameters
        self.initial_radius = Vector3(677.1, 677.1, 900)
        self.initial_orientation = Quaternion(0, 0, 0, 1)

        # Dynamic parameters
        self.current_radius = self.initial_radius
        self.current_orientation = self.initial_orientation
        self.target_radius = self.initial_radius
        self.target_orientation = self.initial_orientation

        self.base_orbit_speed = 0.001  # Base radians per second
        self.current_orbit_speed = self.base_orbit_speed
        self.transition_start_time = None
        self.transition_duration = 5.0  # Default transition duration in seconds

        rospy.Subscriber('/satellite/trajectory', ModelState, self.update_trajectory)
        self.rate = rospy.Rate(10)  # Hz

    def update_trajectory(self, msg):
        # Update target radius and orientation with transition time
        self.target_radius = msg.pose.position
        self.target_orientation = msg.pose.orientation
        self.transition_start_time = rospy.get_time()
        self.transition_duration = msg.twist.linear.y if msg.twist.linear.y != 0 else 5.0  # Use custom duration or default
        self.current_orbit_speed = self.base_orbit_speed * (msg.twist.linear.x if msg.twist.linear.x != 0 else 1.0)

    def interpolate(self, start, end, factor):
        return start + (end - start) * factor

    def interpolate_orientation(self, current, target, factor):
        # Simple linear interpolation for quaternion (not proper for rotation but sufficient for small changes)
        return Quaternion(
            x=self.interpolate(current.x, target.x, factor),
            y=self.interpolate(current.y, target.y, factor),
            z=self.interpolate(current.z, target.z, factor),
            w=self.interpolate(current.w, target.w, factor)
        )

    def move_satellite(self):
        last_time = rospy.get_time()
        accumulated_angle = 0.0
        
        while not rospy.is_shutdown():
            current_time = rospy.get_time()
            time_delta = current_time - last_time
            last_time = current_time

            if self.transition_start_time:
                elapsed = (current_time - self.transition_start_time) / self.transition_duration
                elapsed = min(elapsed, 1.0)  # Cap at 100% to avoid overshooting

                # Smoothly update position and orientation
                self.current_radius = Vector3(
                    x=self.interpolate(self.initial_radius.x, self.target_radius.x, elapsed),
                    y=self.interpolate(self.initial_radius.y, self.target_radius.y, elapsed),
                    z=self.interpolate(self.initial_radius.z, self.target_radius.z, elapsed)
                )
                self.current_orientation = self.interpolate_orientation(self.initial_orientation, self.target_orientation, elapsed)

                if elapsed >= 1.0:
                    self.initial_radius = self.current_radius
                    self.initial_orientation = self.current_orientation
                    self.transition_start_time = None  # End transition

            accumulated_angle += self.current_orbit_speed * time_delta
            accumulated_angle %= (2 * math.pi)  # Normalize angle

            x = self.current_radius.x * math.cos(accumulated_angle)
            y = self.current_radius.y * math.sin(accumulated_angle)
            z = self.current_radius.z  # Maintain constant z for simplicity

            state_msg = ModelState()
            state_msg.model_name = 'chief'
            state_msg.pose.position.x = x
            state_msg.pose.position.y = y
            state_msg.pose.position.z = z
            state_msg.pose.orientation = self.current_orientation
            
            try:
                self.set_state_service(state_msg)
            except rospy.ServiceException as e:
                rospy.logerr(f"Service call failed: {e}")

            self.rate.sleep()

if __name__ == '__main__':
    try:
        controller = SatelliteController()
        controller.move_satellite()
    except rospy.ROSInterruptException:
        pass
